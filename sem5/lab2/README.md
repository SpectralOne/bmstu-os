## Некоторые вопросы к защите

### что мы делаем в обработчике прерывания таймера?
инкримент и выводим X. 

 ;прерывание таймера
  new_int08:  
    push eax
    push edi
    mov edi, 0B8000h
    xor eax, eax
спрашивает что такое 0B8000h? - адресс видеобуффера.



### 64 мб это какая память?
 
- память кот. мы выделили под вирт. машину. (Нам недоступна вся оперативная память.)


### Что за программу мы написали в защищ.режиме
 
- написали управляющую программу с 0 уровнем привилегий.


### что пришлось создать в связи ст ем что программа 0 уровня привилегий. Какую таблицу сегментов создали?
 -таблицы...
- мы создаем 2 сист. табл. Табл. дескр. прер. и табл. дескр. сегментов.


### Этот сегмент является сегментом чего? Стека, кода, данных?

- сегмент, по кот. мы считаем память. (стека данных для подсчета памяти) GDTMEMDESCR


### В сегменте кода можно выполнять read - write?
 
- Можно, а в стек можно делать r-w? да


### У нас есть 16-битный сегмент или еще какие - то? 

- Есть еще 32 битный. (в формате дескриптора посмотреть)


### показать таблицу дескр. прер.


### что делает 13 dup? Выделяет, но как? Почему не выделяем подряд 13 дескрипторов, почему так написали?
 
- Дублруем


### могли бы 32 строки не выделять под исключения?

?

### Что тогда нужно обеспечить, если мы отказываемся от этого?
 
- перепрограммировать контроллер. Базовый вектор меняется с8 на 32 и обратно


### Для этого что они перепрограммируют? в результате формируемый вектор прерываний является ...

?

###  Чем является базовый вектор прерываний? 

- смещение в табл. дескр. прер.


### Какие сегменты объявили, для чего?

?

### для чего объявили 16 разр. сегмент
 
- (посмотреть формат дескрипторов)


### заглушки 	

; обработчик исключения общей защиты (13-я строчка) 	; обработчик всех остальных исключений


### «Чему кратно значение селектора?»

- «8»


### «Что такое индекс?»

- «Смещение в таблице дескрипторов.»


### «В реальном режиме есть привилегии?»

-«Нет»


### «Как вы считаете объем оперативной памяти?»

-«У нас есть сегмент, объемом в 4 гигабайта. Считываем значение из ячейки памяти. 
Сохраняем его. 
Записываем в ячейку свое значение. Считываем. 
Если записанное и считанное значения совпадают, то это память. 

Возвращаем в ячейку первоначальное значение. 
Если значение не совпадают, то пустота. Мы действуем до первого прокола»


### «Какой формат дескриптора?»

?

### «Какие характеристики имеет сегмент «памяти»?»

- «Бит гранулярности устанавливаем в 1, для того, чтобы Лимит был в 4килобайтных единицах. 

Этот сегмент 32разрядный, для того, чтобы описать все адресное пространство»


### «Расскажите о дескрипторах, которые вы описали.»

-«Я описал 6 сегментов: нулевой дескриптор(по правилу), 
сегмент кода, сегмент данных, 
сегмент стека, 
сегмент видеопамяти, сегмент, описывающий все линейное адресное пространство»


### «Что за программу вы написали?»

- «Данная программа выполняет две функции ОС: 
переход в защищенный режим и выделение сегментов памяти, 

описанных в глобальной таблице дескрипторов и размер, 
которых мы подсчитываем в программе»


### «Если не включить линию А20 и перейти в защищенный режим, то что будет?»

- «Если не включить линию А20, то 20ый бит всегда будет равен нулю. 
Если мы захотим обратиться к адресам, в которых этот бит равен единице, 

то мы не сможем получить к ним доступ. Мы получаем «битую память»»


### «Почему вы в реальном режиме используете привилегированную команду lgdt?»

- «Мы можем это делать, т.к. используем директиву .386»


### ряд вопросов по коду, такие как 
«Покажите где вы входите и выходите из защищенного режима», 
«Покажите какие сегменты вы описали»,  
«Что вы делаете до входа и после входа в защищенный режим».


### Что это за программа? Какие у нее особенности? Что в связи с этим вам пришлось объявить?

- Это программа, которая выполняет функции ядра ОС. 
В связи с этим нам пришлось объявить две системный таблицы дескрипторов: 

глобальную – для доступа к памяти и таблицу дескрипторов прерываний – 
для доступа к обработчикам прерываний.


### Почему вдруг ваша программа стала выполнять функции ОС?

- Потому что наша программа работает в защищенном режиме с нулевым уровнем привилегий.


### Есть у вас системные вызовы?

- Нет.

### Если у вас нет системных вызовов, то какие средства вы используете для того, чтобы вводить и выводить символы?

- Для этого мы используем бесконечный цикл. Для того, чтобы вывести символ мы напрямую 
обращаемся к видеопамяти,
 т.к. у нас нет ДОСовской команды вывода страницы.


### Почему существует деление на простые команды и привилегированные?

- Привилегированные команды могут выполняться только с нулевым уровнем привилегий. 

Это нужно для того, чтобы какая-нибудь программа не смогла нарушать работу системы, 
выполнив привилегированную команду.


### могут также попросить рассказать про структура дескриптора таблицы IDT (В особенности о том, как из дескриптора данной таблицы получить адрес обработчика прерываний.)


### Что за число?

16 мб - количество памяти, выделенной виртуальной машине. 

### Что за программа?

Программа 0 уровня привилегий - фактически часть ОС или даже своя ОС.

### Что пришлось создать в памяти?

Две системные таблицы:
ТГД - для правильной адресации по памяти
ТДП - для корректного вычисления обработчика прерываний


### Какие прерывания используются?

 - Клавиатуры
 - Таймера
 

### Что использую в обработчике прерываний от клавиатуры?

Порт клавиатуры



### Где в программе явно указано, что она 0 уровня привилегий?
 
То, что мы используем системные таблицы.


### Рассказать цепочку действий от возникновения прерываний до его обработки

 - Контроллер прерывания получает сигнал о прерывании и формирует вектор прерывания, который содержит селектор из ТДП.
 
- Взяв знаение из регистра IDTR значение базового адреса ТДП. В нём по селектору находим 

 - По этому дискриптору мы находим дескриптор который уже и содержит селектор, смещение и аттрибуты

 - По селектору выбираем дискриптор из ТГД, берём оттуда базовый адрес сегмента и прибавляем егок смещению
 
- Получаем линейный адрес обработчика прерывания
 
### Как и где осуществляется вход/выход в защищенный режим?

?

### Процесс - программа в стадии выполнения. Имеет свою собственную защищенную (другие не имеют доступа) память.

### Что пришлось создать в памяти?

Две системные таблицы:
ТГД - таблица глобальеых дескрипторов для правильной адресации по памяти
в таблце дскрипторов должно быть описано столько дескр-тов сколько сегментов использует программа.
ТДП - таблица дескрипторов прерываний для корректного вычисления обработчика прерываний
регистр gdtr - регистр таблицы глобальных дескрипторов для хранения линейного базового адреса и границы таблицы глобальных дескрипторов.
idtr - регистр таблица дескрипторов прерываний для хранения линейного базового адреса и границы таблицы дескрипторов прерываний.
по 48бит.  от 0 до 15 предел, от 16 до 47 линейный базовый адрес.

### ; структура для описания дескрипторов сегментов.

SDescr		STRUC
	limit	dw	0	; предел (размер сегмента). граница (биты 0..15)
	base_l	dw	0	; мл. слово физ-го адреса (поле 32-х разрядного адреса). база биты 0..15
	base_m	db	0	; ст. слово физ-го адреса. база биты 1..23
	attr1	db	0	; байт атрибутов 1
	attr2	db	0	; границы (биты 16..19) и атрибуты 2
	baseH	db	0	; база биты 24..31
SDescr		ENDS

### ??

граница(limit) сегмента представляет собой номер последнего байта сегмента. поле границы состоит из 20 бит и разбито на две части. младшие 16 бит занимают байты 0 и 1 дескриптора, а старшие 4 бита входят в байт атрибутов 2, занирмая в нём биты 0..3. получается что размер сегмента ограничен величиной 1мб. на самом деле это не так. граница может указываться либо в байтах(и тогда размер сегмента 1мб) либо в блоках по 4кб и тогда размер достигает 4гб. в каких единицах задаётся граница определяет старший бит байта атрибутов 2, называемый битом дробности. если он равен 0 то граница в байтах, если единице то в блоках по 4кб.

### ??

база сегмента 32 бита определяет начальный линейный адрес сегмента в адресном пространстве процесора. линейным называется не сегмент:смещение, а просто номером байта в адресном пр-ве.
в байте атрибутов1 задаётся ряд характеритик сегмента.. для сегмента команд байт атр1 должен иметь значение 98h, для сегмента данных(или стека) 92h.

### какие сегменты и зачем мы объявили?

у нас есть обязательный нулевой дескриптор, и дескрипторы для сегментов данных, комманд, стека и доп-ного сегмента данных, который мы наложим на видеопамять.

### В чём особенность реального режима?

особенность реального режима - ограниче объёма адресуемой оперативной памяти величиной 1мб.

перевод в защ. реж =
1. увеличие адресуемого пространства до 4гб.
2. возможность работать в виртуальном адресном пространстве.
3. организация многозадачного режима с паралельным выполниеем нескольогго программ(процесов)
4. страничная организация памяти, повыщающая уровень защиты задач друг от друга.
в защищённом режиме процесор выполняет процедуру перрывания не так как в реальном. при поступлении сигнала прерывания процессор не обращается к таблице векторов прерываний в первом кб памяти, как в реальном режиме, а извлекает адрес программы обработки прерывания из таблицы дескрипторов прерываний, построенной схоже с ТГД.

в защ. режиме для каждого сегмента должен быть определён дескриптор - 8байтовое поле. в котором записываются базовый адрес сегмента, его длина и некоторые другие хар-ки. для обращения к требуемому сегменты прогрмист заносит в сегментный регистр не сегментный адрес, а так называемый селектор, в состав которого входит номер(индекс) соотвествующего сегмента дескриптора. процесор по этому номеру находит нужный дескриптор, извлекает из него базовый адрес сегмента и прибавляя к нему указанное в конкретной команде смещение(относителньый адрес), формирует адрес ячейки памяти. индекс дескриптора записываются в селектор начиная с бита3, что эквиваленто его умножению на 8.

### Привилегированные команды. 

тридцати двухразрядные микропроцесоры отличаются расширенным набором команд, часть которых относится к привелегированным. для того чтобы разрешить транслятору обрабатывать эти команды в текс включена директива .386Р

### какие действия необходимо выполнить для корректного возвращения в реальный режим - что пишем в теневые регистры и почему.
 
после перехода в защ. режим прога не должна работать, т.к. в регстре CS ещё нет селектора сегмента команд и процесор не может обращаться к этому сгементу. в действительности 
это не совсем так. в процесоре для каждого из сегментных регистров имется так называемый теневой регистр дескриптор, который имеет формат дескриптора. теневые регистры 
недоступны программисту. они автоматически загружаются процесором из таблицы дескрипторов каждый раз, когда процесор инициализуерует соотвующий сегментрный регистр. таким 
образом в защ. режиме пр-мист имеет дело с селекторами, т.е. номерами дескрипторов, а процессор с самими дескрипторами, хранящимися в теневых регистрах. именно содержимое 
теневого регистра(в первую очередь линейный адрес сегмента) определяет область памяти, к которой обращается процесор при выполнении конкретной команды. после перехода в защ. 
режим прежде всего следует загрузить в используемые сегментные регистры селекторы соответствующих сегментов. это позволит процесору правильно заполнить все поля теневых 
регистров из таблиц дескрипторов. к регистру CS недопустимо прямое програмнео обращение, поэтому юзаем переход.
при работе в реальном режиме некоторые поля теневых регистров должны быть заполнены определённым образом. граница ffffh, бит дробности 0, доступ для зписи разрешен. границы 
всех сегментов должны быть точно равны ffffh.перед переходом в реальный режим необходимо исправить все  дескрипторы всех наших сегментов.
линия а20 для обращения к расширеной памяти.

### Просто кусок информации

На процессорном уровне поддерживаются уровни привелегий 0..3; ОС запускается с уровнем 0, приложения с 3. 
Для каждого сегмента памяти устанавливается уровень привелегий, необходимый для доступа.
Существует три режима работы процессора: реальный, защищенный и виртуальный-86. Процессор всегда запускается 
в реальном режиме и выполняет код биоса. После этого он путём плясок с бубном и скакания на [s]майдане[/s] 
костылях переходит в защищённый.

Реальный режим: однозадачный, 16битные регистры, поддерживает до 1 мегабайта памяти. НЕ ПОДДЕРЖИВАЕТ разделение 
доступа (^ уровни 0..3) и виртуальную адресацию памяти. Защищенный - умеет в наоборот: 32битные регистры, 
многозадачность, до 4 ГБ виртуальной памяти. ПОДДЕРЖИВАЕТ уровни доступа (кольца защиты) и виртуальную адресацию. 
В защищенном режиме добавлены несколько дополнительных регистров. Сегментные: FS, GS;  управляющие: CR0, CR1, 
CR2, CR3. Все они, соответственно, 32-разрядные.

Управляющие регистры CR2 и CR3 используются для страничного преобразования, благодаря которому работает 
техномагия виртуальных адресов. В CR0 лежит несколько флагов, которые управляют поведением процессора - например, 
последний (31 (не забываем что нумерация у нас с нуля)) бит Protected отвечает за режим, в котором находится 
процессор - защищённый если ==1 и реальный если ==0. CR1 зарезервирован для будущих поколений процессоров.

Сегменты памяти описываются дескрипторами по 8 байт.

В современных системах, помимо сегментного регистра существует ещё теневой регистр. Про теневые регистры вообще 
нужно сделать небольшое отступление.
Процессоры начиная с 80386 начали поддерживать защищённый режим - для этого в них появились теневые регистры, 
вся адресация памяти теперь проходит через них.
_В РЕАЛЬНОМ_ режиме для обеспечения обратной совместимости при загрузке в CS,DS,SS адреса сегмента 
происходит _неявное_ создание дескриптора сегмента.
MOV		AX,DataSeg
MOV		DS,AX
Где-то на этом участке происходит определение размера сегмента ДатаСег, и создание его дескриптора (8 байт). 
После этого полученные 8 байт сразу же загружаются в теневой регистр (быдлоговоря, DS_shad).
_В ЗАЩИЩЕННОМ_ режиме "основной" сегментный регистр для адресации используется не целиком: его младшие биты (0,1,2) 
содержат в себе флаги (за описаниями к Р. и Ф.).
В качестве смещения используются биты 3..7. Другими словами, если в регистре лежит значение 8d (00001000b), то 
смещение == 00001b. При этом смещение всегда обязательно начинается с 1 - по смещению 0 лежит пустой дескриптор - 
его адрес используется для определения, а где же в памяти лежит сама GDT (Global Descriptor Table).


Таблица глобальных дескрипторов содержит в себе кучу восьмибайтовых структур, каждая из которых имеет следующий вид:
descr struc ;структура для описания декскриптора сегмента
	lim 	dw 0	;Граница (биты 0..15) - размер сегмента в байтах
	base_l 	dw 0	;База, биты 0..15 - базовый адрес задаётся в виртуальном адресном пространстве
	base_m 	db 0	;база, биты 16..23
	attr_1	db 0	;байт атрибутов 1
	attr_2	db 0	;граница(биты 16..19) и атрибуты 2
	base_h 	db 0	;База, биты 24..31
descr ends
База - адрес, с которого начинается данный сегмент. Повторюсь: адрес в _виртуальном_ адресном пространстве. Вообще, 
все упоминаемые здесь и далее адреса упоминаются в контексте виртуальности; к физическим адресам мы доступа не имеем.

Кроме того, используется также таблица дескрипторов прерываний, содержащая в себе следующие структуры:
int_descr struc
	offs_l 	dw 0	;смещение в сегменте, нижняя часть
	sel		dw 0	;селектор сегмента с кодом прерывания
	counter	db 0	;счётчик, не используется в программе
	attr	db 0	;атрибуты
	offs_h 	dw 0	;смещение в сегменте, верхняя часть
int_descr ends
Обработчики 0..16 зарезервированы под прерывания и исключения системы; 17..31 - под "будущие поколения процессоров"; 
остальные могут быть использованы пользователем.
Таким образом, обработчики для аппаратных прерываний должны начинаться минимум с 32-го (в винде принято начинать 
обработку прерываний со смещения 50h, но мы на это забьём, чтобы не пилить ещё дофига лишних обработчиков).
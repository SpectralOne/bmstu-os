\chapter{Функции обработчика прерываний от системного таймера}

В большинстве систем UNIX определенно понятие основного тика, который равен $N$ тикам таймера (число $N$ зависит от конкретного варианта системы).

В каждой {\ttfamily Unix}-машине есть аппаратный таймер, который вырабатывает прерывание в системе через определенные промежутки времени. Период времени между двумя такими прерываниями (тиками) в ОС {\ttfamily Unix} равен 10 мс. Обработчик прерывания по таймеру является вторым по приоритету – первым является обработчик прерывания по сбою питания.

\textbf{Тик} -- период времени между двумя последующими прерываниями таймера.

\textbf{Основной тик} -- период времени равный $N$ тикам таймера, где $N$ -- системозависимая величина.

\textbf{Квант} -- период времени, отведенный планировщиком процессу для выполнения.

\section{UNIX-системы}

Функции обработчика прерываний от системного таймера в UNIX-системах в зависимости от прошедшего времени.

\textbf{По тику:}
\begin{itemize}
	\item инкремент счетчика, отображающего использование процессора текущим процессом;
	\item инкремент часов и других таймеров системы;
	\item декремент счетчика времени, отображающего оставшееся до отправления на выполнение отложенных вызовов;
	\item отправка отложенных вызовов на выполнение при достижении нулевого значения счетчика из предыдущего пункта;
	\item декремент кванта.
\end{itemize}

\textbf{По главному тику:}
\begin{itemize}
	\item добавление в очередь отложенных вызовов функций планировщика;
	\item пробуждение системных процессов {\ttfamily swapper} и {\ttfamily pagedaemon}.
	\item декремент счетчиков времени, отображающих оставшееся до отправления сигналов тревоги время:
	\begin{itemize}
		\item {\ttfamily SIGALARM} --- сигнал будильника реального времени, который отправляется по истичении заданного промежутка реального времени;
		\item {\ttfamily SIGPROF} --- сигнал будильника профиля процесса, который измеряет время работы процесса;
		\item {\ttfamily SIGVTALRM} --- сигнал будильника виртуального времени, который измеряет время работы процесса в режиме задачи.
	\end{itemize}
\end{itemize}

\textbf{По кванту:}
\begin{itemize}
	\item при превышении текущим процессом выделенного кванта, посылка сигнала {\ttfamily SIGXCPU} -- превышение лимита процессорного времени -- этому процессу.
\end{itemize}

\section{Windows-системы}

Всего в ОС Windows 32 уровня запроса прерывания (от 0 до 31). Прерывания обслуживаются в порядке их приоритета. У интервального таймера системных часов высокое значение {\ttfamily IRQL} – {\ttfamily CLOCK\_LEVEL}):

\textbf{По тику:}
\begin{itemize}
	\item инкремент счетчика системного времени;
	\item декремент счетчиков отложенных задач;
	\item декремент кванта текущего потока;
	\item активизация обработчика ловушки профилирования ядра (добавление процесса в очередь {\ttfamily DPC})
\end{itemize}

\textbf{По главному тику:}
\begin{itemize}
	\item инициализация диспетчера настройки баланса (путем освобождения объекта <<событие>>, на котором он ожидает).
\end{itemize}

\textbf{По кванту:}
\begin{itemize}
	\item инициация диспетчеризации потоков (посредством добавления соответствующего объекта {\ttfamily DPC} в очередь).
\end{itemize}

\chapter{Пересчет динамических приоритетов}

\section{UNIX-системы}

Классическое ядро UNIX -- невытесняемое, что означает, что если процесс выполняется в режиме ядра, то ядро не заставит этот процесс уступить процессорное время процессу, имеющему больший приоритет. Выполняющийся процесс освобождает процессор, если произойдет блокирование в ожидании ресурса, иначе он может быть вытеснен при переходе в режим задачи. Такая реализация ядра решает проблемы синхронизации, связанные с доступом нескольких процессов к одним и тем же структурам данных ядра.

Современные ядра Linux, начиная с версии 2.5 -- вытесняемые, так как должны обеспечивать работу процессов реального времени.

\subsection{Приоритеты процессов}

Приоритет процесса в UNIX задается числом в диапазоне от 0 до 127, причем чем меньше значение, тем выше приоритет. Приоритеты 0--49 зарезервированы ядром операционной системы, прикладные процессы могут обладать приоритетом в диапазоне от 50 до 127.

Структура \code{proc} содержит следующие поля, относящиеся к приоритетам:
\begin{itemize}
	\item \code{p{\_}pri} -- текущий приоритет планирования;
	\item \code{p{\_}usrpri} -- приоритет режима задачи;
	\item \code{p{\_}cpu} -- результат последнего измерения использования процессора;
	\item \code{p{\_}nice} -- показатель уступчивости, устанавливаемый пользователем.
\end{itemize}

Планировщик использует поле \code{p{\_}pri} для принятия решения о том, какой процесс отправить на выполнение. Значения \code{p{\_}pri} и \code{p{\_}usrpri} одинаковы, когда процесс находится в режиме задачи. Когда процесс просыпается после блокировки в системном вызове, его приоритет временно повышается. Планировщик использует \code{p{\_}usrpri} для хранения приоритета, который будет назначен процессу при переходе из режима ядра в режим задачи, а \code{p{\_}pri} -- для хранения временного приоритета для выполнения в режиме ядра.

Ядро связывает приоритет сна (0--49) с событием или ожидаемым ресурсом, из-за которого процесс может быть заблокирован. Когда блокированный процесс просыпается, ядро устанавливает \code{p{\_}pri}, равное приоритету сна события или ресурса, на котором он был заблокирован, следовательно, такой процесс будет назначен на выполнение раньше, чем другие процессы в режиме задачи. 

В таблице \ref{tbl:sleeppriority} приведены значения приоритетов сна для систем 4.3BSD UNIX и SCO UNIX. Такой подход позволяет системным вызовам быстрее завершать свою работу. По завершении процессом системного вызова его приоритет сбрасывается в значение текущего приоритета в режиме задачи. Если при этом приоритет окажется ниже, чем приоритет другого запущенного процесса, ядро произведет переключение контекста.
\begin{table}[h]
	\caption{Системные приоритеты сна}
	\begin{center}
		\begin{tabular}{|l|p{75pt}|p{75pt}|} 
			\hline
			\textbf{Событие} & \textbf{Приоритет 4.3BSD UNIX} & \textbf{Приоритет SCO UNIX}\\
			\hline
			{Ожидание загрузки в память страницы} & 0 & 95\\
			\hline
			{Ожидание индексного дескриптора} & 10 & 88\\
			\hline
			{Ожидание ввода--вывода} & 20 & 81 \\
			\hline
			{Ожидание буфера} & 30 & 80\\
			\hline
			{Ожидание терминального ввода} & 30 & 75\\
			\hline
			{Ожидание терминального вывода} & 30 & 74\\
			\hline
			{Ожидание завершения выполнения} & 30 & 73\\
			\hline
			{Ожидание события} & 40 & 66\\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:sleeppriority}
\end{table}

Приоритет в режиме задачи зависит от уступчивости и последней измеренной величины использования процессора. Степень уступчивости -- это число в диапазоне от 0 до 39 со значением 20 по умолчанию. 

Системы разделения времени стараются выделить процессорное время таким образом, чтобы все процессы системы получили его в равных количествах, что требует слежения за использованием процессора. Поле {\ttfamily p{\_}cpu} содержит величину последнего измерения использования процессора процессом. При создании процесса это поле инициализируется нулем. На каждом тике обработчик таймера увеличивает {\ttfamily p{\_}cpu} на единицу для текущего процесса, вплоть до максимального значения -- 127. Каждую секунду ядро вызывает процедуру {\ttfamily schedcpu}, которая уменьшает значение {\ttfamily p{\_}cpu} каждого процесса исходя из фактора <<полураспада>>. 

В 4.3BSD для расчета применяется формула
\[
d = \frac{2\cdot la}{2\cdot la + 1},
\]
где {\ttfamily la} -- {\ttfamily load{\_}average} -- это среднее количество процессов в состоянии готовности за последнюю секунду.

Кроме того, процедура {\ttfamily schedcpu} также пересчитывает приоритеты режима задачи всех процессов по формуле
\[
{p_{usrpri}} = PUSER + \frac{p{\_}cpu}{4} + 2\cdot {p{\_}nice},
\]
где {\ttfamily PUSER} -- базовый приоритет в режиме задачи, равный 50.

Если процесс до вытеснения другим процессом использовал большое количество процессорного времени, его {\ttfamily p{\_}cpu} будет увеличен, что приведет к увеличению значения {\ttfamily p{\_}usrpri} и к понижению приоритета.

Чем дольше процесс простаивает в очереди на выполнение, тем меньше его {\ttfamily p{\_}cpu}. Это позволяет предотвратить зависания низкоприоритетных процессов. Если процесс б\'{о}льшую часть времени выполнения тратит на ожидание ввода-вывода, то он остается с высоким приоритетом.

В системах разделения времени фактор использования процессора обеспечивает справедливость при планировании процессов. Фактор полураспада обеспечивает экспоненциально взвешанное среднее значение использования процессора в течение функционирования процесса. Формула, применяемая в SVR3 имеет недостаток: вычисляя простое экспоненциальное среднее, она способствует росту приоритетов при увеличении загрузки системы.

\section{Windows-системы}

В системе Windows реализовано вытесняющее планирование на основе уровней приоритета, при которой выполняется готовый поток с наивысшим приоритетом.

Процессорное время, выделенное на выполнение потока, называется квантом. Если поток с более высоким приоритетом готов к выполнению, текущий поток вытесняется планировщиком, даже если квант текущего потока не истек.

В Windows за планирование отвечает совокупность процедур ядра, называемая диспетчером ядра. Диспетчеризация может быть вызвана, если:
\begin{itemize}
	\item поток готов к выполнению;
	\item истек квант текущего потока;
	\item поток завершается или переходит в состояние ожидания;
	\item изменился приоритет потока;
	\item изменилась привязка потока к процессору.
\end{itemize}

\subsection{Приоритеты потоков}

В системе предусмотрено 32 уровня приоритетов: уровни реального времени (16--31), динамические уровни (1--15) и системный уровень (0). 

Уровни приоритета потоков назначаются {\ttfamily Windows API} и ядром операционной системы.

{\ttfamily Windows API} сортирует процессы по классам приоритета, которые были назначены при их создании:
\begin{itemize}
	\item реального времени (real-time (4));
	\item высокий (high (3));
	\item выше обычного (above normal (6));
	\item обычный (normal (2));
	\item ниже обычного (below normal (5));
	\item простой (idle (1)).
\end{itemize}

Затем назначается относительный приоритет потоков в рамках процессов:
\begin{itemize}
	\item критичный по времени (time critical (15));
	\item наивысший (highest (2));
	\item выше обычного (above normal (1));
	\item обычный (normal (0));
	\item ниже обычного (below normal (-1));
	\item низший (lowest (-2));
	\item простой (idle (-15)).
\end{itemize}

Относительный приоритет -- это приращение к базовому приоритету процесса.

Соответствие между приоритетами {\ttfamily Windows API} и ядра системы приведено в таблице \ref{tbl:priority}.
\begin{table}[h]
	\caption{Соответствие между приоритетами Windows API и ядра Windows}
	\begin{center}
		\begin{tabular}{|l|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|} 
			\hline
			{} & \textbf{real-time} & \textbf{high} & \textbf{above normal} & \textbf{normal} & \textbf{below normal} & \textbf{idle}\\
			\hline
			\textbf{time critical} & 31 & 15 & 15 & 15 & 15 & 15 \\
			\hline
			\textbf{highest} & 26 & 15 & 12 & 10 & 8 & 6 \\
			\hline
			\textbf{above normal} & 25 & 14 & 11 & 9 & 7 & 5 \\
			\hline
			\textbf{normal} & 24 & 13 & 10 & 8 & 6 & 4 \\
			\hline
			\textbf{below normal} & 23 & 12 & 9 & 7 & 5 & 3 \\
			\hline
			\textbf{lowest} & 22 & 11 & 8 & 6 & 4 & 2 \\
			\hline
			\textbf{idle} & 16 & 1 & 1 & 1 & 1 & 1 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:priority}
\end{table}

C точки зрения планировщика Windows важно только значение приоритета.
Процесс обладает только базовым приоритетом, тогда как поток имеет базовый, который наследуется от приоритета процесса, и текущий приоритет. Операционная система может на короткие интервалы времени повышать приоритеты потоков из динамического диапазона, но никогда не регулирует приоритеты потоков в диапазоне реального времени.
Приложения пользователя обычно запускаются с базовым приоритетом $normal$. Некоторые системные процессы имеют приоритет выше 8, что гарантирует, что потоки в этих процессах будут запускаться с более высоким приоритетом.

Система динамически повышает приоритет текущего потока в следующих случаях:
\begin{itemize}
	\item по завершении операции ввода-вывода;
	\item по окончании ожидания на событии или семафоре исполнительной системы;
	\item по окончании ожидания потоками активного процесса;
	\item при пробуждении {\ttfamily GUI}-потоков из-за операции с окнами;
	\item если поток, готовый к выполнению, задерживается из-за нехватки процессорного времени.
\end{itemize}

Динамическое повышение приоритета применяется только к потокам из динамического диапазона (1--15). Приоритет потока не может оказаться выше 15.

Рассмотрим каждый случай в отдельности.

\subsection{Повышение приоритета по завершении операции ввода-вывода}

По окончании определенных операций ввода-вывода Windows временно повышает приоритет потоков и потоки, ожидающие завершения этих операций, имеют больше шансов возобновить выполнение и обработать полученные от устройств ввода-вывода данные.

Драйвер устройства ввода-вывода через функцию {\ttfamily IoCompleteRequest} указывает на необходимость динамического повышения приоритета после выполнения соответствующего запроса.

В таблице \ref{tbl:priorityinc} приведены приращения приоритетов.
\begin{table}[h]
	\caption{Рекомендованные приращения приоритета}
	\begin{center}
		\begin{tabular}{|p{100mm}|l|} 
			\hline
			\textbf{Устройство} & \textbf{Приращение} \\	
			\hline
			Диск, CD-ROM, параллельный порт, видео & 1 \\
			\hline
			Сеть, почтовый ящик, именованный канал, последовательный порт & 2 \\
			\hline
			Клавиатура, мышь & 6 \\
			\hline
			Звуковая плата & 8 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:priorityinc}
\end{table}

Приоритет потока повышается относительно базового приоритета. На рисунке \ref{img:priority} показано, что после повышения приоритета поток в течение одного кванта выполняется с повышенным приоритетом, а затем приоритет снижается на один уровень с каждым последующим квантом. Цикл продолжается до тех пор, пока приоритет не снизится до базового.

\img{80mm}{priority}{Динамическое изменение приоритета}

\subsection{Повышение приоритета по окончании ожидания на событии или семафоре}

Если ожидание потока на событии системы или семафоре успешно завершается из-за вы {\ttfamily SetEvent}, {\ttfamily PulseEvent} или {\ttfamily ReleaseSemaphore}, его приоритет повышается на 1.
Такая регулировка позволяет равномернее распределить процессорное время -- потокам, блокируемым на событиях, процессорное время требуется реже, чем остальным. В данном случае действуют те же правила динамического повышения приоритета.

К потокам, пробуждающимся в результате установки события вызовом функций {\ttfamily NtSetEventBoostPriority} и {\ttfamily KeSetEventBoostPriority}, повышение приоритета применяется особым образом.

\subsection{Повышение приоритета по окончании ожидания потоками активного процесса}

Если поток в активном процессе завершает ожидание на объекте ядра, функция ядра {\ttfamily KiUnwaitThread} повышает его текущий приоритет на величину значения {\ttfamily PsPrioritySeparation}. {\ttfamily PsPrioritySeparation} -- это индекс в таблице квантов, с помощью которой выбираются величины квантов для потоков активных процессов. Какой процесс является в данный момент активным, определяет подсистема управления окнами.

Приоритет повышается для создания преимуществ интерактивным приложениям по окончании ожидания, в результате чего повышаются шансы на возобновление потока приложения.
Важной особенностью данного вида динамического повышения приоритета является то, что он поддерживается всеми системами Windows и не может быть отключен даже функцией {\ttfamily SetThreadPriorityBoost}.

\subsection{Повышение приоритета при пробуждении GUI-потоков}

Приоритет потоков окон пользовательского интерфейса повышается на 2 после их пробуждения из-за активности подсистемы управления окнами. Приоритет повышается по той же причине, что и в предыдущем случае, -- для увеличения отзывчивости интерактивных приложений.

\subsection{Повышение приоритета при нехватке процессорного времени}

Раз в секунду диспетчер настройки баланса -- системный поток, предназначенный для выполнения функций управления памятью -- сканирует очереди готовых потоков и ищет потоки, которые находятся в состоянии готовности в течение примерно 4 секунд. Диспетчер настройки баланса повышает приоритет таких потоков до 15. Причем в {\ttfamily Windows 2000} и {\ttfamily Windows XP} квант потока удваивается относительно кванта процесса, а в {\ttfamily Windows Server 2003} квант устанавливается равным 4 единицам. По истечении кванта приоритет потока снижается до исходного уровня. Если потоку все еще не хватило процессорного времени, то после снижения приоритета он возвращается в очередь готовых процессов. Через 4 секунды он может снова получить повышение приоритета.

Чтобы свести к минимуму расход процессорного времени, диспетчер настройки баланса сканирует только 16 готовых потоков за раз, а повышает приоритет не более чем у 10 потоков за раз.
Диспетчер настройки баланса не решает всех проблем с приоритетами потоков, однако позволяет потокам, которым не хватает процессорного времени, получить его.

\subsection{Уровни запросов прерываний}

Windows использует схему приоритетов прерываний, называемую уровни запросов прерываний ({\ttfamily IRQL}). Внутри ядра {\ttfamily IRQL} представляются в виде номеров до 0 до 31 для систем x86. Ядро определяет стандартный набор {\ttfamily IRQL} для программных прерываний, а HAL связывает {\ttfamily IRQL} с номерами аппаратных прерываний (см. рис. \ref{img:irql}).

\img{80mm}{irql}{Уровни запросов прерываний}

Прерывания обслуживаются в порядке их приоритета. Прерывания с б\'{о}льшим приоритетом вытесняют прерывания с меньшим приоритетом.

При возникновении прерывания с высоким приоритетом процессор сохраняет информацию о состоянии прерванного потока и активизирует сопоставленный с данным прерыванием диспетчер ловушки. Последний повышает {\ttfamily IRQL} и вызывает процедуру обслуживания прерывания --- {\ttfamily ISR (Interrupt Service Routine)}. 

После выполнения {\ttfamily ISR} диспетчер прерывания понижает {\ttfamily IRQL} процессора до исходного уровня и загружает сохраненные ранее данные о состоянии машины. Прерванный поток возобновляется с той точки, где он был прерван. Когда ядро понижает {\ttfamily IRQL}, могут начать обрабатываться ранее замаскированные прерывания с более низким приоритетом. Тогда вышеописанный процесс повторяется ядром для обработки и этих прерываний.

\chapter*{Вывод}

Операционные системы {\ttfamily UNIX} и {\ttfamily Windows} являются системами разделения времени с вытеснением. В связи с этим обработчики прерываний от системных таймеров в них выполняют схожие функции:
\begin{itemize}
	\item обновление системного времени;
	\item отправление отложенных вызовов на выполнение;
	\item уменьшение кванта процессорного времени, выделенного процессу;
	\item перепланировка задач.
\end{itemize}

Такую схожесть можно объяснить тем, что обе системы являются системами разделения времени с вытеснением и динамическими приоритетами.

В то же время в планировании и пересчете приоритетов эти системны отличаются.

{\ttfamily Windows} является полностью вытесняющий, а {\ttfamily Unix/Linux} имеет невытесняющее ядро.
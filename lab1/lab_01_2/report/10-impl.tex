\chapter{Функции обработчика прерываний от системного таймера}

В большинстве систем UNIX определенно понятие основного тика, который равен $N$ тикам таймера (число $N$ зависит от конкретного варианта системы).

В каждой {\ttfamily Unix}-машине есть аппаратный таймер, который вырабатывает прерывание в системе через определённые промежутки времени. Период времени между двумя такими прерываниями (тиками) в ОС {\ttfamily Unix} равен 10 мс. Обработчик прерывания по таймеру является вторым по приоритету – первым является обработчик прерывания по сбою питания.

\textbf{Тик} -- период времени между двумя последующими прерываниями таймера.

\textbf{Основной тик} -- период времени равный $N$ тикам таймера, где $N$ -- системозависимая величина.

\textbf{Квант} -- период времени, отведенный планировщиком процессу для выполнения.

\section{ОС семейства Unix/Linux}

Обработчик прерывания от системного таймера \textbf{по тику} выполняет следующие задачи:
\begin{itemize}
	\item инкрементирует счётчик тиков аппаратного таймера;
	\item обновляет часы и другие таймеры системы;
	\item обновляет статистику использования процессора текущим процессом: инкремент поля {\ttfamily p\_cpu} дескриптора текущего процесса на единицу, до максимального значения, равного 127;
	\item декрементирует счётчик времени до отправления на выполнение отложенных вызов. Если счётчик достиг нуля, то выставление флага для обработчика отложенных вызов;
	\item декрементирует квант текущего потока.
\end{itemize}

Обработчик прерывания от системного таймера \textbf{по главному тику} выполняет следующие задачи:
\begin{itemize}
	\item регистрирует отложенные вызовы функций, относящиеся к работе планировщика, такие как пересчет приоритетов;
	\item пробуждает из состояния прерываемого сна системных процессов {\ttfamily swapper} и {\ttfamily pagedaemon}.
	\item декрементирует счётчик времени, оставшегося до посылки одного из следующих сигналов:
	\begin{itemize}
		\item {\ttfamily SIGALRM} – сигнал, посылаемый процессу по истечении времени, предварительно заданного функцией {\ttfamily alarm()};
		\item {\ttfamily SIGPROF} –  сигнал, посылаемый процессу по истечении времени заданного в таймере профилирования;
		\item {\ttfamily SIGVTALRM} –  сигнал, посылаемый процессу по истечении времени, заданного в ``виртуальном'' таймере.
	\end{itemize}
\end{itemize}

Обработчик прерывания от системного таймера \textbf{по кванту} выполняет следующие задачи:
\begin{itemize}
	\item при превышении текущим процессом выделенного кванта, посылает сигнал {\ttfamily SIGXCPU} -- превышение лимита процессорного времени -- этому процессу.
\end{itemize}

\section{Windows-системы}

Всего в ОС Windows 32 уровня запроса прерывания (от 0 до 31). Прерывания обслуживаются в порядке их приоритета. У интервального таймера системных часов высокое значение {\ttfamily IRQL} – {\ttfamily CLOCK\_LEVEL}):

Обработчик прерывания от системного таймера \textbf{по тику} выполняет следующие задачи:
\begin{itemize}
	\item инкрементирует счётчик системного времени;
	\item декрементирует квант текущего потока на величину, равную количеству тактов процессора, произошедших за тик. Если количество затраченных потоком тактов процессора достигает квантовой цели, запускается обработка истечения кванта;
	\item декрементирует счётчики времени отложенных задач;
	\item если активен механизм профилирования ядра, то инициализирует отложенный вызов обработчика ловушки профилирования ядра путём постановки объекта в очередь {\ttfamily DPC}: обработчик ловушки профилирования регистрирует адрес команды, выполнявшейся на момент прерывания. 
\end{itemize}

Обработчик прерывания от системного таймера \textbf{по главному тику} выполняет следующие задачи:
\begin{itemize}
	\item инициализирует диспетчер настройки баланса (путем освобождения объекта <<событие>>, на котором он ожидает).
\end{itemize}

Обработчик прерывания от системного таймера \textbf{по кванту} выполняет следующие задачи:
\begin{itemize}
	\item инициализирует диспетчеризацию потоков путем постановки соответствующего объекта в очередь {\ttfamily DPC}.
\end{itemize}

\chapter{Пересчёт динамических приоритетов}

\section{ОС семейства Unix/Linux}

В ОС семейства {\ttfamily Unix/Linux} динамически пересчитываться могут только приоритеты пользовательских процессов.

Очередь готовых к выполнению процессов формируется согласно приоритетам процессов и принципу вытесняющего циклического планирования: процессы с одинаковыми приоритетами выполняются в течении кванта времени циклически друг за другом. Если процесс, имеющий более высокий приоритет, поступает в очередь готовых к выполнению, планировщик вытесняет текущий процесс и предоставляет ресурс более приоритетному. 

В современных системах {\ttfamily Unix} ядро является вытесняющим – процесс в режиме ядра может быть вытеснен более приоритетным процессом в режиме ядра.

 

Дескриптор процесса proc содержит следующие поля, относящиеся к приоритету:

\subsection{Приоритеты процессов}

Приоритет процесса в {\ttfamily UNIX} задаётся числом в диапазоне от 0 до 127, причём чем меньше значение, тем выше приоритет. Приоритеты 0--49 зарезервированы ядром операционной системы, прикладные процессы могут обладать приоритетом в диапазоне от 50 до 127. Приоритеты ядра являются фиксированными величинами.

Приоритеты прикладных задач могут изменяться во времени в зависимости от следующих двух факторов:

\begin{itemize}
	\item фактор любезности – целое число в диапазоне от 0 до 39. Чем меньше значение фактора любезности, тем выше приоритет процесса. Фактор любезности процесса может быть изменён суперпользователем системным вызовом {\ttfamily nice};
	
	\item степень загруженности процессора в момент последнего обслуживания им процесса.
\end{itemize}

Структура \code{proc} содержит следующие поля, относящиеся к приоритетам:
\begin{itemize}
	\item \code{p{\_}pri} -- текущий приоритет планирования;
	\item \code{p{\_}usrpri} -- приоритет режима задачи;
	\item \code{p{\_}cpu} -- результат последнего измерения использования процессора;
	\item \code{p{\_}nice} -- показатель уступчивости, устанавливаемый пользователем.
\end{itemize}

Планировщик использует поле \code{p{\_}pri} для принятия решения о том, какой процесс отправить на выполнение. Значения \code{p{\_}pri} и \code{p{\_}usrpri} одинаковы, когда процесс находится в режиме задачи. Когда процесс просыпается после блокировки в системном вызове, его приоритет временно повышается. Планировщик использует \code{p{\_}usrpri} для хранения приоритета, который будет назначен процессу при переходе из режима ядра в режим задачи, а \code{p{\_}pri} -- для хранения временного приоритета для выполнения в режиме ядра.

Ядро связывает приоритет сна (0--49) с событием или ожидаемым ресурсом, из-за которого процесс может быть заблокирован. Когда блокированный процесс просыпается, ядро устанавливает \code{p{\_}pri}, равное приоритету сна события или ресурса, на котором он был заблокирован, следовательно, такой процесс будет назначен на выполнение раньше, чем другие процессы в режиме задачи. 

В таблице \ref{tbl:sleeppriority} приведены значения приоритетов сна для систем {\ttfamily 4.3BSD UNIX} и {\ttfamily SCO UNIX}. Такой подход позволяет системным вызовам быстрее завершать свою работу. По завершении процессом системного вызова его приоритет сбрасывается в значение текущего приоритета в режиме задачи. Если при этом приоритет окажется ниже, чем приоритет другого запущенного процесса, ядро произведет переключение контекста.
\begin{table}[h]
	\caption{Системные приоритеты сна}
	\begin{center}
		\begin{tabular}{|l|p{75pt}|p{75pt}|} 
			\hline
			\textbf{Событие} & \textbf{Приоритет 4.3BSD UNIX} & \textbf{Приоритет SCO UNIX}\\
			\hline
			{Ожидание загрузки в память страницы} & 0 & 95\\
			\hline
			{Ожидание индексного дескриптора} & 10 & 88\\
			\hline
			{Ожидание ввода--вывода} & 20 & 81 \\
			\hline
			{Ожидание буфера} & 30 & 80\\
			\hline
			{Ожидание терминального ввода} & 30 & 75\\
			\hline
			{Ожидание терминального вывода} & 30 & 74\\
			\hline
			{Ожидание завершения выполнения} & 30 & 73\\
			\hline
			{Ожидание события} & 40 & 66\\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:sleeppriority}
\end{table}

Приоритет в режиме задачи зависит от уступчивости и последней измеренной величины использования процессора. Степень уступчивости -- это число в диапазоне от 0 до 39 со значением 20 по умолчанию. 

Системы разделения времени стараются выделить процессорное время таким образом, чтобы все процессы системы получили его в равных количествах, что требует слежения за использованием процессора. Поле {\ttfamily p{\_}cpu} содержит величину последнего измерения использования процессора процессом. При создании процесса это поле инициализируется нулем. На каждом тике обработчик таймера увеличивает {\ttfamily p{\_}cpu} на единицу для текущего процесса, вплоть до максимального значения -- 127. Каждую секунду ядро вызывает процедуру {\ttfamily schedcpu}, которая уменьшает значение {\ttfamily p{\_}cpu} каждого процесса исходя из фактора <<полураспада>>. 

В {\ttfamily 4.3BSD} для расчета применяется формула
\[
d = \frac{2\cdot la}{2\cdot la + 1},
\]
где {\ttfamily la} -- {\ttfamily load{\_}average} -- это среднее количество процессов в состоянии готовности за последнюю секунду.

Кроме того, процедура {\ttfamily schedcpu} также пересчитывает приоритеты режима задачи всех процессов по формуле
\[
{p_{usrpri}} = PUSER + \frac{p{\_}cpu}{4} + 2\cdot {p{\_}nice},
\]
где {\ttfamily PUSER} -- базовый приоритет в режиме задачи, равный 50.

Если процесс до вытеснения другим процессом использовал большое количество процессорного времени, его {\ttfamily p{\_}cpu} будет увеличен, что приведет к увеличению значения {\ttfamily p{\_}usrpri} и к понижению приоритета.

Чем дольше процесс простаивает в очереди на выполнение, тем меньше его {\ttfamily p{\_}cpu}. Это позволяет предотвратить зависания низкоприоритетных процессов. Если процесс б\'{о}льшую часть времени выполнения тратит на ожидание ввода-вывода, то он остается с высоким приоритетом.

Системы разделения времени пытаются выделить процессорное время таким образом, чтобы конкурирующие процессы получили его примерно в равных количествах. Фактор полураспада обеспечивает экспоненциально взвешанное среднее значение использования процессора в течение функционирования процесса. Формула, применяемая в SVR3 имеет недостаток: вычисляя простое экспоненциальное среднее, она способствует росту приоритетов при увеличении загрузки системы.

\section{Windows-системы}

В системе Windows реализовано вытесняющее планирование на основе уровней приоритета, при которой выполняется готовый поток с наивысшим приоритетом.

Если поток с более высоким приоритетом готов к выполнению, текущий поток вытесняется планировщиком, даже если квант текущего потока не истёк.

В {\ttfamily Windows} за планирование отвечает совокупность процедур ядра, называемая диспетчером ядра. Диспетчеризация может быть вызвана, если:
\begin{itemize}
	\item поток готов к выполнению;
	\item истёк квант текущего потока;
	\item поток завершается или переходит в состояние ожидания;
	\item изменился приоритет потока;
	\item изменилась привязка потока к процессору.
\end{itemize}

\subsection{Приоритеты потоков}

В системе предусмотрено 32 уровня приоритетов: уровни реального времени (16--31), динамические уровни (1--15) и системный уровень (0). 

Уровни приоритета потоков назначаются {\ttfamily Windows API} и ядром операционной системы.

{\ttfamily Windows API} сортирует процессы по классам приоритета, которые были назначены при их создании:
\begin{itemize}
	\item реального времени (real-time (4));
	\item высокий (high (3));
	\item выше обычного (above normal (6));
	\item обычный (normal (2));
	\item ниже обычного (below normal (5));
	\item простой (idle (1)).
\end{itemize}

Затем назначается относительный приоритет потоков в рамках процессов:
\begin{itemize}
	\item критичный по времени (time critical (15));
	\item наивысший (highest (2));
	\item выше обычного (above normal (1));
	\item обычный (normal (0));
	\item ниже обычного (below normal (-1));
	\item низший (lowest (-2));
	\item простой (idle (-15)).
\end{itemize}

Относительный приоритет -- это приращение к базовому приоритету процесса.

Соответствие между приоритетами {\ttfamily Windows API} и ядра системы приведено в таблице \ref{tbl:priority}.
\begin{table}[h]
	\caption{Соответствие между приоритетами Windows API и ядра Windows}
	\begin{center}
		\begin{tabular}{|l|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|} 
			\hline
			{} & \textbf{real-time} & \textbf{high} & \textbf{above normal} & \textbf{normal} & \textbf{below normal} & \textbf{idle}\\
			\hline
			\textbf{time critical} & 31 & 15 & 15 & 15 & 15 & 15 \\
			\hline
			\textbf{highest} & 26 & 15 & 12 & 10 & 8 & 6 \\
			\hline
			\textbf{above normal} & 25 & 14 & 11 & 9 & 7 & 5 \\
			\hline
			\textbf{normal} & 24 & 13 & 10 & 8 & 6 & 4 \\
			\hline
			\textbf{below normal} & 23 & 12 & 9 & 7 & 5 & 3 \\
			\hline
			\textbf{lowest} & 22 & 11 & 8 & 6 & 4 & 2 \\
			\hline
			\textbf{idle} & 16 & 1 & 1 & 1 & 1 & 1 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:priority}
\end{table}

C точки зрения планировщика {\ttfamily Windows} важно только значение приоритета.
Процесс обладает только базовым приоритетом, тогда как поток имеет базовый, который наследуется от приоритета процесса, и текущий приоритет. Операционная система может на короткие интервалы времени повышать приоритеты потоков из динамического диапазона, но никогда не регулирует приоритеты потоков в диапазоне реального времени.
Приложения пользователя обычно запускаются с базовым приоритетом $normal$. Некоторые системные процессы имеют приоритет выше 8, что гарантирует, что потоки в этих процессах будут запускаться с более высоким приоритетом.

Система динамически повышает приоритет текущего потока в следующих случаях:
\begin{itemize}
	\item по завершении операции ввода-вывода;
	\item по окончании ожидания на событии или семафоре исполнительной системы;
	\item по окончании ожидания потоками активного процесса;
	\item при пробуждении {\ttfamily GUI}-потоков из-за операции с окнами;
	\item если поток, готовый к выполнению, задерживается из-за нехватки процессорного времени.
\end{itemize}

Динамическое повышение приоритета применяется только к потокам из динамического диапазона (1--15). Приоритет потока не может оказаться выше 15.

Рассмотрим каждый случай в отдельности.

\subsection{Повышение приоритета по завершении операции ввода-вывода}

По окончании определенных операций ввода-вывода Windows временно повышает приоритет потоков и потоки, ожидающие завершения этих операций, имеют больше шансов возобновить выполнение и обработать полученные от устройств ввода-вывода данные.

Драйвер устройства ввода-вывода через функцию {\ttfamily IoCompleteRequest} указывает на необходимость динамического повышения приоритета после выполнения соответствующего запроса.

В таблице \ref{tbl:priorityinc} приведены приращения приоритетов.
\begin{table}[h]
	\caption{Рекомендованные приращения приоритета}
	\begin{center}
		\begin{tabular}{|p{100mm}|l|} 
			\hline
			\textbf{Устройство} & \textbf{Приращение} \\	
			\hline
			Диск, CD-ROM, параллельный порт, видео & 1 \\
			\hline
			Сеть, почтовый ящик, именованный канал, последовательный порт & 2 \\
			\hline
			Клавиатура, мышь & 6 \\
			\hline
			Звуковая плата & 8 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:priorityinc}
\end{table}

Приоритет потока повышается относительно базового приоритета. На рисунке \ref{img:priority} показано, что после повышения приоритета поток в течение одного кванта выполняется с повышенным приоритетом, а затем приоритет снижается на один уровень с каждым последующим квантом. Цикл продолжается до тех пор, пока приоритет не снизится до базового.

\img{80mm}{priority}{Динамическое изменение приоритета}

\subsection{Повышение приоритета по окончании ожидания на событии или семафоре}

Если ожидание потока на событии системы или семафоре успешно завершается из-за вы {\ttfamily SetEvent}, {\ttfamily PulseEvent} или {\ttfamily ReleaseSemaphore}, его приоритет повышается на 1.
Такая регулировка позволяет равномернее распределить процессорное время -- потокам, блокируемым на событиях, процессорное время требуется реже, чем остальным. В данном случае действуют те же правила динамического повышения приоритета.

К потокам, пробуждающимся в результате установки события вызовом функций {\ttfamily NtSetEventBoostPriority} и {\ttfamily KeSetEventBoostPriority}, повышение приоритета применяется особым образом.

\subsection{Повышение приоритета по окончании ожидания потоками активного процесса}

Если поток в активном процессе завершает ожидание на объекте ядра, функция ядра {\ttfamily KiUnwaitThread} повышает его текущий приоритет на величину значения {\ttfamily PsPrioritySeparation}. {\ttfamily PsPrioritySeparation} -- это индекс в таблице квантов, с помощью которой выбираются величины квантов для потоков активных процессов. Какой процесс является в данный момент активным, определяет подсистема управления окнами.

Приоритет повышается для создания преимуществ интерактивным приложениям по окончании ожидания, в результате чего повышаются шансы на возобновление потока приложения.
Важной особенностью данного вида динамического повышения приоритета является то, что он поддерживается всеми системами Windows и не может быть отключен даже функцией {\ttfamily SetThreadPriorityBoost}.

\subsection{Повышение приоритета при пробуждении GUI-потоков}

Приоритет потоков окон пользовательского интерфейса повышается на 2 после их пробуждения из-за активности подсистемы управления окнами. Приоритет повышается по той же причине, что и в предыдущем случае, -- для увеличения отзывчивости интерактивных приложений.

\subsection{Повышение приоритета при нехватке процессорного времени}

Раз в секунду диспетчер настройки баланса -- системный поток, предназначенный для выполнения функций управления памятью -- сканирует очереди готовых потоков и ищет потоки, которые находятся в состоянии готовности в течение примерно 4 секунд. Диспетчер настройки баланса повышает приоритет таких потоков до 15. Причем в {\ttfamily Windows 2000} и {\ttfamily Windows XP} квант потока удваивается относительно кванта процесса, а в {\ttfamily Windows Server 2003} квант устанавливается равным 4 единицам. По истечении кванта приоритет потока снижается до исходного уровня. Если потоку все еще не хватило процессорного времени, то после снижения приоритета он возвращается в очередь готовых процессов. Через 4 секунды он может снова получить повышение приоритета.

Чтобы свести к минимуму расход процессорного времени, диспетчер настройки баланса сканирует только 16 готовых потоков за раз, а повышает приоритет не более чем у 10 потоков за раз.
Диспетчер настройки баланса не решает всех проблем с приоритетами потоков, однако позволяет потокам, которым не хватает процессорного времени, получить его.

\chapter*{Вывод}

Функции обработчика прерывания от системного таймера в защищенном режиме для семейства ОС {\ttfamily Windows} и для семейства OC {\ttfamily UNIX/Linux} схожи по своим действиям:
\begin{itemize}
	\item инициализируют отложенные действия, относящиеся к работе планировщика, такие как пересчёт приоритетов;
	\item выполняют декремент счётчиков времени: часов, таймеров, будильников реального времени, счётчиков времени отложенных действий;
	\item выполняют декремент кванта: текущего процесса в {\ttfamily Linux}, текущего потока в {\ttfamily Windows}.
\end{itemize}

Обе системы являются системами разделения времени с динамическими приоритетами и вытеснением, пересчёт динамических приоритетов в данных системах можно описать следующим образом:

\begin{itemize}
	\item при создании процесса в {\ttfamily Windows}, ему назначается базовый приоритет. Приоритеты потоков определяются относительно приоритета процесса, в котором они создаются. Приоритет потока пользовательского процесса может быть пересчитан динамически;
	
	\item в {\ttfamily Unix/Linux} приоритет процесса характеризуется текущим приоритетом и приоритетом процесса в режиме задачи. Приоритет пользовательского процесса может быть динамически пересчитан.
\end{itemize}